







/*
ok, without renaming sticker.js to library-1, essentially
you are exporting some of these fundamentals
so feel free to import them from here as you code onwards
and then later, and maybe, actually remove them from library0, and refactor everyone to get them from here, instead

library0 can still be no imports
it's just that now you get Tag from sticker, not library1!




*/



//october resolve this current thing where you've got sayTick in sticker and library0; have it use wrapper local minute number, have it be only in sticker, grand means importers don't care where it's from
//october, oh look, now that process.env is replaced with Access, sayTick needs an import, and so can no longer by in library0! take care of this in the grand refactor. sticker is small but allows imports, library0 is huge with no imports, library1+ can be big or small and can have imports
//^october yeah that didn't work at all, you need to rethink time zones now that getting to secrets is hard
	//october so actually here you need a light access that doesn't throw
	//october restore the local time zone feature, probably moving it from access to wrapper




















//import { Access } from './library2.js'//october you have to get rid of this because it'll bring in the whole library. you realize now this means access will go here into sticker, and that's probably fine? or, put the time zone in wrapper, you guess. although here in sticker is fine probably because sticker is the library that is small and absolutely fundamental, with tick and tag and environment detection and shrinkwrap information, so environment variables and secrets make sense here
//^october didn't work at all, just commented out the custom time zone feature for now


/*
TODO october []resolve this and other todo tags tagged as october
you've tagged "october" elsewhere in the code related to this, take care of them all soon!

october notes are in:
PasswordComponent.vue
library0.js
library2.js
sticker.js, here
test.js

updating wrangler meant you had to get secrets through nuxt
so you wrote Access,
and have to call saveUseRuntimeConfigFunction(useRuntimeConfig) for it to work

you're using ACCESS_ for three things
1 actual api keys
2 the local time zone
3 public factory presets
4 there are also those personal email addresses and phone numbers in env.js

the issue with 2 is you want sticker to be fast and reliable
so maybe move local time zone to wrapper

for 3, return to just putting them in the .vue file, this was fine

for 4, soon those can go away because you'll just type them into a box on a page
thinking academically, are they compromised even if not in source code, like do they get built into the compiled front end?
you could put 2 in here, if you keep this around. really, though, you should just make 2 a minute number in wrapper.js so it's quick and easy for sticker to get

for 1, it's working, but it's a cumbersome mess
so here's a cowboy bike shed idea:
there's only one secret, the private key which decrypts them all
this is in .env files, .dev.vars, lambda, cloudflare, nuxt, all those places
the details are encrypted and encoded base62 in wrapper.js or a separate file

benefits:
you can see and set your secrets locally, in one place not five
you can iterate through all of them, assuredly, you don't need a list of them as another one
you have them all, or none of them, so you won't run into just one is different or broken
no worry of formatting or encoding differences all the different environments

design:
secret.txt - git ignores it but shrinkwrap hashes it
secret.js - $ node secret packages it up
(more)
where's the public key? this doesn't need to be in git
(keep this separate, or add this as a feature to shrinkwrap)


october draft design of encrypted secrets
maybe the flow is like this
./.env is set once at the start by hand, where you set the private key, which you also put in the cloudflare dashboard
the developer changes .env once at the start of this system
./.env.secret has the public key, comments, and secrets like ACCESS_SOME_SECRET=blah blah blah
seal encrypts that into a string, which it puts in
the developer changes .env.secret each time they want to edit or change secrets
./wrapper.js
node shrink sets the ciphertext in wrapper js each time it runs
the contents of wrapper.js get built into the public deployed code for all environments
Access gets the private key from ./env in development, wherever serverless framework put it for lambda, and the cloudflare dashboard

.env and .env.secret are dot hidden, git ignored, but also shrinkwrap hashed
wrapper.js is not shrinkwrap hashed

wrapper.js also has another property for local time zone, in minutes
so Sticker calling sayTick can use it without needing to get secrets or use encryption


all in all
very secure
you can change back to hidden secrets later
lets you do this
-set the secrets one place, not five places
-know you got all the secrets, because otherwise you'd get none of them
-lets you loop through the secrets
all avoiding vendor-specific code







*/






























important feature:
if a secret value has a character that json stringify escapes
then redacting it by finding the value won't work
so have a scanner throw if a value named _SECRET isn't found after a little sample stringification
and write a test to show true positives and negatives for this working












async function secretSnippet1() {
	log('hi from secret snippet 1')
//	log(look(previousWrapper))

	/*
	here we want to
	-read the previous secret hash from wrapper
	-compute the has of the secret file on disk
	-pass the contents of the file and those hashes to a helper function in access, for now
	*/




}



noop(async () => {
let messageText = `
Lorem ipsum odor amet, consectetuer adipiscing elit. Phasellus non nam litora rutrum erat eu at gravida. Sapien ante curabitur hac at mattis finibus. Curae nostra nullam turpis justo ex sagittis conubia integer. Pellentesque efficitur sem; mi elementum id conubia. Nec ex arcu ultricies tristique lobortis class. Ornare lorem viverra nulla aliquam, vulputate egestas.
Risus aliquam ultrices urna vestibulum est inceptos vulputate. Scelerisque nulla varius dolor nisi tempor, semper ex litora. Proin ipsum nostra magnis; volutpat montes lectus. Eros metus augue malesuada vitae per suscipit. Quam etiam ipsum luctus ad felis mus mattis. Sollicitudin curae finibus mattis vestibulum quam, ridiculus torquent sit. Torquent suspendisse ex torquent sed; quam viverra torquent. Imperdiet sit lacinia, sociosqu in aptent fringilla etiam. Ante sem lorem congue bibendum fames habitasse congue odio. Sapien nascetur litora augue lacinia accumsan litora magnis.
Fermentum facilisis rhoncus lobortis vel tristique tortor nisi. Ipsum magnis natoque ex netus montes. Duis non eros fusce viverra convallis potenti tortor mus. At primis felis nisi libero dapibus eget ultrices. Molestie lacus pulvinar pharetra lacus pretium dignissim. Dis tristique auctor nascetur tempus tortor, morbi tellus natoque. Sem bibendum enim eget blandit egestas augue vulputate felis torquent.
Fames sem vitae ac sit, non hac ut curabitur. Dapibus erat porta purus ligula cubilia elementum. Libero cubilia facilisi varius vulputate, sit auctor gravida mi netus. Molestie tortor libero mauris velit ac consequat duis. Commodo eu nullam tincidunt rhoncus tortor dignissim ultrices aliquam. Libero aliquam duis tincidunt proin viverra, consequat luctus.
Posuere est feugiat duis mollis; fringilla sagittis etiam. Ornare accumsan torquent cursus augue pretium elementum fringilla suspendisse ipsum. Taciti sollicitudin cubilia felis consequat nullam dictumst metus venenatis. Fermentum aliquam ultrices arcu facilisis libero urna lacus. Rhoncus elit aliquam ligula habitant et; quis feugiat sagittis inceptos. Aliquam aliquam sit tellus quisque consectetur aenean aliquet. Felis class phasellus litora montes nam id ultrices. Aenean ultrices ad pulvinar a commodo sollicitudin. Massa augue tempus semper potenti fringilla habitasse suspendisse aptent.
`
let t1 = Now()
let keyData = await accessCreateKey()
let t2 = Now()
let cipherData = await accessEncrypt(keyData, messageText)
let t3 = Now()
let decryptedText = await accessDecrypt(keyData, cipherData)
let t4 = Now()
ok(messageText == decryptedText)
log(`
${t2-t1}ms to create key
${t3-t2}ms to encrypt
${t4-t3}ms to decrypt

${messageText.length}
${cipherData.base62().length}
`)





})






/*
test(() => {

	log(look(wrapper))


log(codeString)


})
*/

/*
instead of manually writing javascript in a string above, chat suggests this:

import fs from 'fs/promises';
import { wrapper as previousWrapper } from './wrapper.js';
import util from 'util';

const Now = () => Date.now();
const hash = { base32: () => 'newHashValue' }; // Replace with your hash function
const codeFiles = 120; // Example value
const codeSize = 600000; // Example value
const totalFiles = 125; // Example value
const totalSize = 9000000; // Example value

// Update properties
const updatedWrapper = {
...previousWrapper,
tick: Now(),
hash: hash.base32(),
codeFiles,
codeSize,
totalFiles,
totalSize,
};

// Serialize to code string
const objectToCode = (obj) => util.inspect(obj, { depth: null, maxArrayLength: null });
const codeString = `export const wrapper = Object.freeze(${objectToCode(updatedWrapper)});\n`;

// Write to 'wrapper.js'
await fs.writeFile('wrapper.js', codeString);



*/








/*
//turn a tick count into text like "Fri04:09p39.470s", short but specific for logs and development bliss
export function sayTick1(t) {//takes a tick count from Date.now() which is in UTC
	if (!t) return '(not yet)'//don't render 1970jan1 as a time something actually happened
	let d = new Date(t + (wrapper.local * 3600000))//offset manually, then we'll use UTC methods below
	let weekday = d.toUTCString().slice(0, 3)//then use UTC
	let hours = (d.getUTCHours() % 12 || 12).toString().padStart(2, '0')//convert hours 0-23 to 1-12
	let meridiem = d.getUTCHours() < 12 ? 'a' : 'p'
	let minutes = d.getUTCMinutes().toString().padStart(2, '0')
	let seconds = d.getUTCSeconds().toString().padStart(2, '0')
	let milliseconds = d.getUTCMilliseconds().toString().padStart(3, '0')
	return `${weekday}${hours}:${minutes}${meridiem}${seconds}.${milliseconds}s`
}

//here's the first function, which currently makes a DateTimeFormat()

//say a tick count t like "Sat11:29a04.702s" in the local time zone that I, reading logs, am in now
export function sayTick2(t) {

	//in this unusual instance, we want to say the time local to the person reading the logs, not the computer running the script
	let zone = Intl.DateTimeFormat().resolvedOptions().timeZone//works everywhere, but will be utc on cloud worker and lambda
//	zone = Access('ACCESS_TIME_ZONE')//use what we set in the .env file. page script won't have access to .env, but worker and lambda, local and deployed will

	let d = new Date(t)
	let f = new Intl.DateTimeFormat('en', {timeZone: zone, weekday: 'short', hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit'})
	let parts = f.formatToParts(d)

	let weekday = parts.find(p => p.type == 'weekday').value
	let hour = parts.find(p => p.type == 'hour').value
	let minute = parts.find(p => p.type == 'minute').value
	let second = d.getSeconds().toString().padStart(2, '0')
	let millisecond = d.getMilliseconds().toString().padStart(3, '0')
	let ap = parts.find(p => p.type == 'dayPeriod').value == 'AM' ? 'a' : 'p'

	return `${weekday}${hour}:${minute}${ap}${second}.${millisecond}s`
}


//starting not with a named time zone, nor getting local time from the system, what are some ways to compose a short developer human-readable date?
*/


test(() => {

	let t = Now()
	log(sayDate(0), sayDate(t), sayTick(t))





})













