






//october
/*
//new draft pattern for importing very environment-specific stuff in a library file that gets called from dispirate environments
let useRuntimeConfig//the nuxt api, or left undefined if nitro isn't running us
(async () => {//conditional import is await, so function that calls it must be async
	try {
		let name = 'imports'
		if (typeof globalThis !== 'undefined' && globalThis.NITRO_ENV) {//avoid the overhead of creating an exception each time non-nitro environments run this. looking for a check here that can have false positives (leading to exceptions) but never false negatives (leading to not importing something that could be imported)
			(//parenthesis so javascript doesn't see the object dereference as the start of a code block
				{ useRuntimeConfig } = (await new Function(`return import('#${name}')`)())//safer than eval, but similar, and prevents vite from not being able to deal with the code containing an import statement to something it can't find
			)
		}
	} catch () {}//catch and discard the type error from importing something that isn't there
})()

ok, that^ didn't work
it's basically impossible to dynamically import a named something that isn't there

you like the Access(name) thing below, how it gets them from different sources, how it tosses so you don't need to check for blank

what if door, on cloudflare, just fills Access with variables from useRuntimeConfig()
*/





/*
ok, without renaming sticker.js to library-1, essentially
you are exporting some of these fundamentals
so feel free to import them from here as you code onwards
and then later, and maybe, actually remove them from library0, and refactor everyone to get them from here, instead

library0 can still be no imports
it's just that now you get Tag from sticker, not library1!




*/



//october resolve this current thing where you've got sayTick in sticker and library0; have it use wrapper local minute number, have it be only in sticker, grand means importers don't care where it's from
//october, oh look, now that process.env is replaced with Access, sayTick needs an import, and so can no longer by in library0! take care of this in the grand refactor. sticker is small but allows imports, library0 is huge with no imports, library1+ can be big or small and can have imports
//^october yeah that didn't work at all, you need to rethink time zones now that getting to secrets is hard
	//october so actually here you need a light access that doesn't throw
	//october restore the local time zone feature, probably moving it from access to wrapper




















//import { Access } from './library2.js'//october you have to get rid of this because it'll bring in the whole library. you realize now this means access will go here into sticker, and that's probably fine? or, put the time zone in wrapper, you guess. although here in sticker is fine probably because sticker is the library that is small and absolutely fundamental, with tick and tag and environment detection and shrinkwrap information, so environment variables and secrets make sense here
//^october didn't work at all, just commented out the custom time zone feature for now


/*
TODO october []resolve this and other todo tags tagged as october
you've tagged "october" elsewhere in the code related to this, take care of them all soon!

october notes are in:
PasswordComponent.vue
library0.js
library2.js
sticker.js, here
test.js

updating wrangler meant you had to get secrets through nuxt
so you wrote Access,
and have to call saveUseRuntimeConfigFunction(useRuntimeConfig) for it to work

you're using ACCESS_ for three things
1 actual api keys
2 the local time zone
3 public factory presets
4 there are also those personal email addresses and phone numbers in env.js

the issue with 2 is you want sticker to be fast and reliable
so maybe move local time zone to wrapper

for 3, return to just putting them in the .vue file, this was fine

for 4, soon those can go away because you'll just type them into a box on a page
thinking academically, are they compromised even if not in source code, like do they get built into the compiled front end?
you could put 2 in here, if you keep this around. really, though, you should just make 2 a minute number in wrapper.js so it's quick and easy for sticker to get

for 1, it's working, but it's a cumbersome mess
so here's a cowboy bike shed idea:
there's only one secret, the private key which decrypts them all
this is in .env files, .dev.vars, lambda, cloudflare, nuxt, all those places
the details are encrypted and encoded base62 in wrapper.js or a separate file

benefits:
you can see and set your secrets locally, in one place not five
you can iterate through all of them, assuredly, you don't need a list of them as another one
you have them all, or none of them, so you won't run into just one is different or broken
no worry of formatting or encoding differences all the different environments

design:
secret.txt - git ignores it but shrinkwrap hashes it
secret.js - $ node secret packages it up
(more)
where's the public key? this doesn't need to be in git
(keep this separate, or add this as a feature to shrinkwrap)


october draft design of encrypted secrets
maybe the flow is like this
./.env is set once at the start by hand, where you set the private key, which you also put in the cloudflare dashboard
the developer changes .env once at the start of this system
./.env.secret has the public key, comments, and secrets like ACCESS_SOME_SECRET=blah blah blah
seal encrypts that into a string, which it puts in
the developer changes .env.secret each time they want to edit or change secrets
./wrapper.js
node shrink sets the ciphertext in wrapper js each time it runs
the contents of wrapper.js get built into the public deployed code for all environments
Access gets the private key from ./env in development, wherever serverless framework put it for lambda, and the cloudflare dashboard

.env and .env.secret are dot hidden, git ignored, but also shrinkwrap hashed
wrapper.js is not shrinkwrap hashed

wrapper.js also has another property for local time zone, in minutes
so Sticker calling sayTick can use it without needing to get secrets or use encryption


all in all
very secure
you can change back to hidden secrets later
lets you do this
-set the secrets one place, not five places
-know you got all the secrets, because otherwise you'd get none of them
-lets you loop through the secrets
all avoiding vendor-specific code







*/






























important feature:
if a secret value has a character that json stringify escapes
then redacting it by finding the value won't work
so have a scanner throw if a value named _SECRET isn't found after a little sample stringification
and write a test to show true positives and negatives for this working












async function secretSnippet1() {
	log('hi from secret snippet 1')
//	log(look(previousWrapper))

	/*
	here we want to
	-read the previous secret hash from wrapper
	-compute the has of the secret file on disk
	-pass the contents of the file and those hashes to a helper function in access, for now
	*/




}



noop(async () => {
let messageText = `
Lorem ipsum odor amet, consectetuer adipiscing elit. Phasellus non nam litora rutrum erat eu at gravida. Sapien ante curabitur hac at mattis finibus. Curae nostra nullam turpis justo ex sagittis conubia integer. Pellentesque efficitur sem; mi elementum id conubia. Nec ex arcu ultricies tristique lobortis class. Ornare lorem viverra nulla aliquam, vulputate egestas.
Risus aliquam ultrices urna vestibulum est inceptos vulputate. Scelerisque nulla varius dolor nisi tempor, semper ex litora. Proin ipsum nostra magnis; volutpat montes lectus. Eros metus augue malesuada vitae per suscipit. Quam etiam ipsum luctus ad felis mus mattis. Sollicitudin curae finibus mattis vestibulum quam, ridiculus torquent sit. Torquent suspendisse ex torquent sed; quam viverra torquent. Imperdiet sit lacinia, sociosqu in aptent fringilla etiam. Ante sem lorem congue bibendum fames habitasse congue odio. Sapien nascetur litora augue lacinia accumsan litora magnis.
Fermentum facilisis rhoncus lobortis vel tristique tortor nisi. Ipsum magnis natoque ex netus montes. Duis non eros fusce viverra convallis potenti tortor mus. At primis felis nisi libero dapibus eget ultrices. Molestie lacus pulvinar pharetra lacus pretium dignissim. Dis tristique auctor nascetur tempus tortor, morbi tellus natoque. Sem bibendum enim eget blandit egestas augue vulputate felis torquent.
Fames sem vitae ac sit, non hac ut curabitur. Dapibus erat porta purus ligula cubilia elementum. Libero cubilia facilisi varius vulputate, sit auctor gravida mi netus. Molestie tortor libero mauris velit ac consequat duis. Commodo eu nullam tincidunt rhoncus tortor dignissim ultrices aliquam. Libero aliquam duis tincidunt proin viverra, consequat luctus.
Posuere est feugiat duis mollis; fringilla sagittis etiam. Ornare accumsan torquent cursus augue pretium elementum fringilla suspendisse ipsum. Taciti sollicitudin cubilia felis consequat nullam dictumst metus venenatis. Fermentum aliquam ultrices arcu facilisis libero urna lacus. Rhoncus elit aliquam ligula habitant et; quis feugiat sagittis inceptos. Aliquam aliquam sit tellus quisque consectetur aenean aliquet. Felis class phasellus litora montes nam id ultrices. Aenean ultrices ad pulvinar a commodo sollicitudin. Massa augue tempus semper potenti fringilla habitasse suspendisse aptent.
`
let t1 = Now()
let keyData = await accessCreateKey()
let t2 = Now()
let cipherData = await accessEncrypt(keyData, messageText)
let t3 = Now()
let decryptedText = await accessDecrypt(keyData, cipherData)
let t4 = Now()
ok(messageText == decryptedText)
log(`
${t2-t1}ms to create key
${t3-t2}ms to encrypt
${t4-t3}ms to decrypt

${messageText.length}
${cipherData.base62().length}
`)





})






/*
test(() => {

	log(look(wrapper))


log(codeString)


})
*/

/*
instead of manually writing javascript in a string above, chat suggests this:

import fs from 'fs/promises';
import { wrapper as previousWrapper } from './wrapper.js';
import util from 'util';

const Now = () => Date.now();
const hash = { base32: () => 'newHashValue' }; // Replace with your hash function
const codeFiles = 120; // Example value
const codeSize = 600000; // Example value
const totalFiles = 125; // Example value
const totalSize = 9000000; // Example value

// Update properties
const updatedWrapper = {
...previousWrapper,
tick: Now(),
hash: hash.base32(),
codeFiles,
codeSize,
totalFiles,
totalSize,
};

// Serialize to code string
const objectToCode = (obj) => util.inspect(obj, { depth: null, maxArrayLength: null });
const codeString = `export const wrapper = Object.freeze(${objectToCode(updatedWrapper)});\n`;

// Write to 'wrapper.js'
await fs.writeFile('wrapper.js', codeString);



*/








/*
//turn a tick count into text like "Fri04:09p39.470s", short but specific for logs and development bliss
export function sayTick1(t) {//takes a tick count from Date.now() which is in UTC
	if (!t) return '(not yet)'//don't render 1970jan1 as a time something actually happened
	let d = new Date(t + (wrapper.local * 3600000))//offset manually, then we'll use UTC methods below
	let weekday = d.toUTCString().slice(0, 3)//then use UTC
	let hours = (d.getUTCHours() % 12 || 12).toString().padStart(2, '0')//convert hours 0-23 to 1-12
	let meridiem = d.getUTCHours() < 12 ? 'a' : 'p'
	let minutes = d.getUTCMinutes().toString().padStart(2, '0')
	let seconds = d.getUTCSeconds().toString().padStart(2, '0')
	let milliseconds = d.getUTCMilliseconds().toString().padStart(3, '0')
	return `${weekday}${hours}:${minutes}${meridiem}${seconds}.${milliseconds}s`
}

//here's the first function, which currently makes a DateTimeFormat()

//say a tick count t like "Sat11:29a04.702s" in the local time zone that I, reading logs, am in now
export function sayTick2(t) {

	//in this unusual instance, we want to say the time local to the person reading the logs, not the computer running the script
	let zone = Intl.DateTimeFormat().resolvedOptions().timeZone//works everywhere, but will be utc on cloud worker and lambda
//	zone = Access('ACCESS_TIME_ZONE')//use what we set in the .env file. page script won't have access to .env, but worker and lambda, local and deployed will

	let d = new Date(t)
	let f = new Intl.DateTimeFormat('en', {timeZone: zone, weekday: 'short', hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit'})
	let parts = f.formatToParts(d)

	let weekday = parts.find(p => p.type == 'weekday').value
	let hour = parts.find(p => p.type == 'hour').value
	let minute = parts.find(p => p.type == 'minute').value
	let second = d.getSeconds().toString().padStart(2, '0')
	let millisecond = d.getMilliseconds().toString().padStart(3, '0')
	let ap = parts.find(p => p.type == 'dayPeriod').value == 'AM' ? 'a' : 'p'

	return `${weekday}${hour}:${minute}${ap}${second}.${millisecond}s`
}


//starting not with a named time zone, nor getting local time from the system, what are some ways to compose a short developer human-readable date?
*/


test(() => {

	let t = Now()
	log(sayDate(0), sayDate(t), sayTick(t))





})







/*
currently, a secret is like process.env.ACCESS_PASSWORD_SECRET
and code that tries to use it is like

let v
if (defined(process) && hasText(process.env?.ACCESS_PASSWORD_SECRET)) {
	v = process.env?.ACCESS_PASSWORD_SECRET
}

so that's clumsy, if standard
but now that cloudflare is doing secrets away from process.env
you have both an excuse and requirement to code your own system

all of your environment variables are called ACCESS_, so your function is Access()

how about
let v = Access('ACCESS_PASSWORD_SECRET')
and it never returns blank--if not defined, it tosses

yeah, this might simplify code


*/







//oh, this also means you have to await Access(); not sure about that, actually
//see how slow it is, too
/*
await loadAccess()//do that once at the top of every function that needs them?

await awaitLoadAccess()
you have to call that at the top of any function that uses access
no, that's a crazy side effect that's worse than await Access() everywhere

or
let access = await awaitLoadAccess()
then you use access.ACCESS_SOME_SECRET
but you don't like that, because if that object got logged, wow


the other idea is you have one secret everywhere, which is base62 of text of file that Access() parses and  returns details from
here, it's fast and synchronous
and there's no ciphertext that looks compelling to try to crack
downsides are
you might run into a length limit at some point with a provider
you can't change keys locally, you have to go into the cloudflare dashboard whenever you want to change them

looking at code, having Access async doesn't look that bad
it'll asyncize:
door open
supabase client creation
but there are already used in async call stacks

so maybe go forward with this whole crazy plan!?
*/

/*
refactor both rsa and sign for actual use, now they're more generalized

if you do async Access, you have to
redact both the _SECRET values, and the private key itself
guard against portions of a secret getting logged--break each secret into parts and redact the parts, probably
only if a certain length, and a trailing tip isn't too short
*/

/*
additional thoughts about Access
do it like this
const access = await asyncGetAccess()
access.get('ACCESS_SOME_SECRET')
this way it can blow up if not found at the top, and only the top needs to be awaited
also, things only get parsed once, and redaction is a method now, because it knows all the secrets
access.redact(s)

ok, here's teh dealbreaker that will kill encryping secrets as an idea
are you easily able to call await redact()?
like, not in dog()!
so then the way to do it is to have door open produce this side effect that Access works
or, dog doesn't redact?!



instead of decrypting, you could also just bundle up base64 and have one giant blob secret
benefits
-no compelling thing for hackerz to try to decrypt
-faster and cheaper on the server
-get access without an await
drawbacks
-if you change or add a secret, you have to go into the files and dashboards
but for production, this is probably the right plan
either way, you have to be careful to redact both the long key (private key, or blob of encoded secrets) AND the individual secret values, because either can expose all the secrets

*/

/*
october
what if your naming convention for exported async functions that return promises is start with underscore
a little weird because collides with start with underscore meaning private helper or do not touch
*/



/*
there might be a natural prefix to look for, "Up9WR6SXEX9HK", for redact to confirm the private key is not leaking
*/

//above is how you wrap stringify for crypto; use here and probably in higher level functions for sign and verify below, also


//so maybe down here these use array, buffer, directly; all the Data is in the simplified ones above



/*
	let keys = await rsaCreateKeys()
	let keyPublicStringified = await rsaExportKey(keys.publicKey)
	let keyPrivateStringified = await rsaExportKey(keys.privateKey)

	//let's package up the keys further
	let keyPublicBase62 = Data({text: keyPublicStringified}).base62()
	let keyPrivateBase62 = Data({text: keyPrivateStringified}).base62()

	let keyPublicImported = await rsaImportKey(Data({base62: keyPublicBase62}).text(), true)
	let keyPrivateImported = await rsaImportKey(Data({base62: keyPrivateBase62}).text(), false)

	//next, let's encrypt a message with the imported public key
	let message = "Hello, RSA encryption!"
	let cipherData = await rsaEncrypt(keyPublicImported, message)
	//log(cipherData.base62())

	let decryptedMessage = await rsaDecrypt(keyPrivateImported, cipherData)
	log(decryptedMessage.text())


	//and decrypt it with the imported private key

	// Step 5: Encrypt a message using the public key
/*
	// Step 6: Decrypt the message using the private key
	let decryptedMessage = await rsaDecrypt(keyPrivateImported, Data({buffer: encryptedMessage}))
	log("Decrypted message:", Data({buffer: decryptedMessage}).text())

	// Verify the decrypted message matches the original
	ok(message === Data({buffer: decryptedMessage}).text())
	log("RSA encryption and decryption were successful!")
*/
/*
export async function rsaEncrypt(publicKey, plainText) {
	let encoded = new TextEncoder().encode(plainText); // Convert text to Uint8Array
	let encrypted = await crypto.subtle.encrypt(
		{
			name: 'RSA-OAEP',
		},
		publicKey,
		encoded
	);
	return Data({ buffer: encrypted }); // Encrypted data returned as Data object
}
export async function rsaDecrypt(privateKey, cipherData) {
	let decrypted = await crypto.subtle.decrypt(
		{
			name: 'RSA-OAEP',
		},
		privateKey,
		cipherData.array()
	);
	return Data({ text: new TextDecoder().decode(decrypted) }); // Convert Uint8Array back to text
}
test(async () => {
	// Step 1: Create a key pair
	let keyPair = await rsaCreateKeys();

	// Step 2: Export the public and private keys
	let publicKeyData = await rsaExportKey(keyPair.publicKey);
	let privateKeyData = await rsaExportKey(keyPair.privateKey);

	// Step 3: Import the keys
	let importedPublicKey = await rsaImportKey(publicKeyData, 'public');
	let importedPrivateKey = await rsaImportKey(privateKeyData, 'private');

	ok(importedPublicKey instanceof CryptoKey);
	ok(importedPrivateKey instanceof CryptoKey);

	// Step 4: Encrypt a message using the public key
	let message = 'Hello, this is a secret message!';
	let encryptedMessage = await rsaEncrypt(importedPublicKey, message);

	// Step 5: Decrypt the message using the private key
	let decryptedMessage = await rsaDecrypt(importedPrivateKey, encryptedMessage);

	ok(message === decryptedMessage.text()); // Ensure the decrypted message matches the original
});
*/






















/*
cloudflare and nuxt do secrets separate from process.env
so here you want to write Access(), callable from anywhere
which lists them, and has them already redacted, and so on

rather than trying to pin them to process.env before code reads it
*/



/*
ok, so it's the isomorphic and lazy loading problem again
what if you just eat the exceptions, who cares, how long do they take, really?
so at the top of the file, you try to load each block, saying, this is only going to work on amazon, this is only goign to work on cloudflare, etc
because the alternative is hairy:
-environment detection before trying, which is imprecise
-lazy loading has to be async, so then you can't call from a regular function
*/








/*
use symmetric encryption
the private key is these places:
.dev.vars
.env
it doesn't need to be in .env.secret




oh, also, the random initialization vector means that you can just encrypt every $ node shrink
you don't need to detect a change in the secret file and only do it then
this is a lot simpler








*/


/*
in the seal step, we must:
-get the previous secret file hash from wrapper.js
-compute the current secret file hash
compare them, if they're different:
-store the new secret file hash
-encrypt just the secrets





in the run step, we must:
-get the private key from a local development file or a cloud secret
-get the encrypted secrets from wrapper.js
-decrypt the secrets in an enclosed module scope variable behind Access()


*/


test(() => {

/*
// Update properties
const s = {
...previousWrapper,
tick: Now(),
hash: hash.base32(),
codeFiles,
codeSize,
totalFiles,
totalSize,
};

// Serialize to code string
const objectToCode = (obj) => util.inspect(obj, { depth: null, maxArrayLength: null });
const codeString = `export const wrapper = Object.freeze(${objectToCode(s)});\n`;


const codeString = `export const wrapper = Object.freeze(${JSON.stringify(updatedWrapper, null, 2)});\n`;



*/


})







/*
export function replaceAll(s, tag1, tag2) {//in s, find all instances of tag1, and replace them with tag2
	checkText(tag1); checkText(tag2)
	return s.split(tag1).join(tag2)
}
export function replaceOne(s, tag1, tag2) {//this time, only replace the first one
	checkText(tag1); checkText(tag2)//replace's behavior only works this way if tag1 is a string!
	return s.replace(tag1, tag2)
}
test(() => {
	ok(replaceAll('abc', 'd', 'e') == 'abc')//make sure not found doesn't change the string
	ok(replaceOne('abc', 'd', 'e') == 'abc')

	let s1 = 'ABABthis sentence ABcontains text and tagsAB to find and replaceAB'
	let s2 = 'CCthis sentence Ccontains text and tagsC to find and replaceC'
	ok(replaceAll(s1, 'AB', 'C') == s2)

	let size = 6789
	ok(replaceOne(
		'first ‹SIZE› and second ‹SIZE› later', '‹SIZE›', `‹${size}›`) ==
		'first ‹6789› and second ‹SIZE› later')
})
*/





noop(async () => {

	//create and export key for symmetric encryption
	let key = await symmetricCreateKey()
	let keyData = await symmetricExportKey(key)
	log(keyData.size(), keyData.base16(), keyData.base32(), keyData.base62())//32 bytes, we're going to use base16 for access key secret

	//maybe make a wrapper for symmetric encrypt that imports and decrypts as a single step

	//import it again, taking it through base62 text
	let keyImported = await symmetricImportKey(Data({base62: keyData.base62()}))
	ok(key instanceof CryptoKey)//both keys look good
	ok(keyImported instanceof CryptoKey)

	//encrypt a short message
	let p = 'a short message'//plaintext p, a string
	let c = await symmetricEncrypt(p, keyImported)//ciphertext c, a Data
	let d = await symmetricDecrypt(c, keyImported)//decrypted plaintext d, a Data
	ok(p == d.text())//we got the same message back out again!
})


export async function secretSnippet2(keyBase62, secretFileContents) {

	let cipherData = await accessEncrypt(Data({base62: keyBase62}), secretFileContents)
	log(cipherData.base62(), cipherData.base62().length)







}



export function hasAccess() {//true if we can get to secrets
	return getUseRuntimeConfigFunction() || (defined(typeof process) && process.env)
}
//^ 
pretty sure you don't need this, but here it is in case you go diggign for it, for now







//also this replaces test.js
/*

//this script just bundles together all the library files that have tiny tests
import { runTests } from './library0.js'
import './library1.js'
import './library2.js'
import './door.js'
import './door2.js'
import './database.js'
import './cloud.js'
import './cloud2.js'

//so you can import just one thing from here
export { runTests }//curly braces as part of named export system in javascript
*/



//grand.js





//grand like grand central station
//or maybe instead nexus like star trek or plexus like chakras?


/*
thsi is also where you can document package.json



where do you install a module taht will be used only by lambda?
needs to be available to

library - yes
net23 - yes
site - no



needs to be







*/

/*
a note about yarn

have these environments:

/ root nuxt for cloudflare, or maybe put that in a subfolder, too?
/library, this is where you do $ node test, not in the root, so that there can be node test library-only modules
/icarus
/net23

so you'll have four, not three

*/

/*
this will be the pass through imports library
so you can move a function from library1 to library2 without changing a bunch of imports in code files

you might also bring in database, cloud, and door functions here

and also this is where you channel sticker.js
but ping files still import sticker.js by itself to be really lean



*/

/*
oh, this is also where you document what each file is for, and what code goes in each file
which is better than doing that at the top of each file, because this one place can see the whole map

*/

/*
an early fun thing you'll unwind here is which functions from library0 get brought up to sticker
*/


/*
// File: moduleA.js
export const valueA = 'Hello';

// File: moduleB.js
export { valueA } from './moduleA';

// Now you can import valueA from moduleB.js:
import { valueA } from './moduleB';



before you switch to this with a lot of keystrokes:
confirm you can import in loops, like library2 imports grand, which imports functions from library2
confirm you can stack import statements from the same file, so that you can group these thematically

and then go file by file and condense imports to grand
and actually only import things you're using, which is cleaner, and also eliminates some build warnings




*/



function composeJsStyleFile(o) {

}
function parseJsStyleFile(s) {
	//actually, you don't use this, you import it and javascript parses it for you
}
function composeEnvStyleFile(o) {
	let s = ''
	Object.entries(o).forEach(([k, v]) => {
		s += k+'='+v+newline
	})
	return s
}


/*
above, you can parse and compose a env-style file
next, you need to do that for wrapper.js, so you can parse it with extra stuff that stays the same

and maybe even have nested objects, and Object.freeze, too
*/










//     _    ____ ____ _____ ____ ____                        _        ____  _____ ____ ____  _____ _____ 
//    / \  / ___/ ___| ____/ ___/ ___|        __ _ _ __   __| |      / ___|| ____/ ___|  _ \| ____|_   _|
//   / _ \| |  | |   |  _| \___ \___ \       / _` | '_ \ / _` |      \___ \|  _|| |   | |_) |  _|   | |  
//  / ___ \ |__| |___| |___ ___) |__) |     | (_| | | | | (_| |       ___) | |__| |___|  _ <| |___  | |  
// /_/   \_\____\____|_____|____/____/____   \__,_|_| |_|\__,_|  ____|____/|_____\____|_| \_\_____| |_|  
//                                  |_____|                     |_____|                                  

/*
a note about secrets and environment variables

locally, they're at:
./.env        for nuxt and cloudflare
./net23/.env  for serverless framework and amazon lambda
./card.js     for node snippet, mostly

all three of those are ignored by git, but haashed by shrinkwrap
card.js contains personal info used in testing, like email addresses and phone numbers, rather than, like, api keys

serverless framework automatically deploys net23's .env to amazon lambda
but to use individual ones in lambda code, you have to mention them in serverless.yml

cloudflare keeps them in the dashboard, and you keep them in sync manually

ACCESS_ is the prefix for all of them
those that should be redacted have the suffix _SECRET
nuxt has a way to expose some to page code, but for those, we're instead just using const in .vue files
those are allowed to be known, and have the suffix _PUBLIC
an example is the first password hashing salt in the password component .vue file
*/
const _secretSuffix = '_SECRET'
export function redact(s) {
	let words = s.match(/\w+/g)
	let secretNamesSet = new Set()
	words.forEach(word => { if (word.endsWith(_secretSuffix)) secretNamesSet.add(word) })
	let secretNames = Array.from(secretNamesSet)
	let secretValues = []
	if (defined(typeof process)) secretNames.forEach(secretName => { secretValues.push(process.env[secretName]) })//october this will change when you're reading Access('ACCESS_SECRET_LIST') to get the names to redact
	secretValues.forEach(secretValue => {
		let redactedValue = redact_composeReplacement(secretValue)
		s = replaceAll(s, secretValue, redactedValue)
	})
	return s
	/*
	two notes on choosing this design, which gets secret names from s, then secret values from process.env:
	-why not just look in process.env for property names that end _SECRET? lambda let's us do this, but cloudflare does not
	-why not avoid process entirely, and parse s like "SOME_SECRET":"secret value"? combinations of stringify and look mean that secret values are bound by " or \" or potentially other terminators!
	*/
}
const _redactLabel = '##REDACTED##'//what the black marker looks like
const _redactMargin = 2//but we mark messily, letting tips this big stick out on either end
function redact_composeReplacement(s) {//given a secret value like "some secret value", return "so##REDACTED###ue"
	let c = ''//redacted string we will compose and return
	let both = _redactMargin*2//length of both leading and trailing margins
	if (s.length < _redactLabel.length + both) {//short, run the black marker over the whole thing
		c = '#'.repeat(s.length)
	} else {//long enough to show label and let margins show through
		let extraBlackMarker = '#'.repeat(s.length - both - _redactLabel.length)
		c = s.slice(0, _redactMargin)+'##REDACTED##'+extraBlackMarker+s.slice(-_redactMargin)
	}
	return c
}
test(() => {
	ok(redact_composeReplacement('') == '')
	ok(redact_composeReplacement('abc') == '###')//short becomes all pound, always the same length
	ok(redact_composeReplacement(
		'abcdefghijklmnopqrstuvwxyz') ==//long says redacted, and lets tips show through
		'ab##REDACTED############yz')
})




export function redact(s) {
	let words = s.match(/\w+/g)
	let secretNamesSet = new Set()
	words.forEach(word => { if (word.endsWith(_secretSuffix)) secretNamesSet.add(word) })
	let secretNames = Array.from(secretNamesSet)
	let secretValues = []
	if (defined(typeof process)) secretNames.forEach(secretName => { secretValues.push(process.env[secretName]) })//october this will change when you're reading Access('ACCESS_SECRET_LIST') to get the names to redact
	secretValues.forEach(secretValue => {
		let redactedValue = redact_composeReplacement(secretValue)
		s = replaceAll(s, secretValue, redactedValue)
	})
	return s
}









function redact_composeReplacement(s) {//given a secret value like "some secret value", return "so##REDACTED###ue"
	let c = ''//redacted string we will compose and return
	let both = _redactMargin*2//length of both leading and trailing margins
	if (s.length < _redactLabel.length + both) {//short, run the black marker over the whole thing
		c = '#'.repeat(s.length)
	} else {//long enough to show label and let margins show through
		let extraBlackMarker = '#'.repeat(s.length - both - _redactLabel.length)
		c = s.slice(0, _redactMargin)+_redactLabel+extraBlackMarker+s.slice(-_redactMargin)
	}
	return c
}
test(() => {
	ok(redact_composeReplacement('') == '')
	ok(redact_composeReplacement('abc') == '###')//short becomes all pound, always the same length
	ok(redact_composeReplacement(
		'abcdefghijklmnopqrstuvwxyz') ==//long says redacted, and lets tips show through
		'ab##REDACTED############yz')
})




/*

you could combine sticker and library0
by pass-through importing all of sticker's exports at the top of library0
and then importing them from library0 elsewhere
yeah, do this









*/


//library2 is for library functions more specific to this project than general-purpose
//grow them here, then probably refactor them out into named files in this library folder
//actually don't do this, it's library1.js and the named files



//no imports allowed in library0! if you need one, go to library1
//well, this brings in sticker, which brings in nanoid, but both of those are small
















