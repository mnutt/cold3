














/*
trail notes
you've been doing a great job of making each of these a one screen show!

[x]check
[x]integer, text convert
[x]data, text convert
[x]string clip to parse
[x]string validation, like only alphanumeric, regex from chatgpt
[x]randbetween, inclusive, just in case you need it
[x]ticks to nice text for the user in the current time zone, see if you can avoid a library actually--yes, you can avoid a library and do all the internationalization you need, and very succinctly
[x]say four digit byte size, don't otherwise internationalize numbers

[]browser crypto, symmetric and asymetric, hashing
[~]uri encoding, get taht in here just for compleness, have tests that show one+space or one%20space
[]email validation, another one for chatgpt, 1raw, 2cleaned for use, 3normalized for duplicate detection

do all the text checking you need for the database
and for validating single-line user input, like a screen name
not, at this time, the text checking for a user writing a comment


*/




























//maybe wrap json parse and stringify to deal with errors you've encountered





//    _                 
//   (_)___  ___  _ __  
//   | / __|/ _ \| '_ \ 
//   | \__ \ (_) | | | |
//  _/ |___/\___/|_| |_|
// |__/                 

export function jsonStringify(o) {//watch out for a circular reference
	/*
//watch out for a circular reference
try {
return JSON.stringify(o, null)//single line
} catch (e) { return '(circular reference)' }//watch out for circular references
*/
}

export function jsonParse(s) {//watch out for a blank body
	/*
//watch out for a blank body
//get the text first, and keep that, too

r.responseText = await response.text()//might be nothing, even on success
if (r.responseText) r.responseData = JSON.parse(r.responseText)//throws if you give it nothing
*/

}



























/*
2024apr26
code encoding, some bikeshedding

[x]from separate project entry point, Ctrl+S leads to green or red check on page

library0 ~

[]base16 data
[]base64 data
[]base62 data, your code
[]base62 integer, chatGPT's code

[]round trip check
[]toss on failure
[]speed test your base62 with the browser's base64

library1 ~

[]random 1-9
[]random 0-9
[]random 0-9 A-Z a-z

not in scope for this first pass:
-page rendered width analysis
-unicode search for narrow accents that still render
-unified chinese base256





*/







/*

2014may17 hopefully good thinking on finishing off this bike shed

inspect
if you want to inspect an object directly, and y ou know you're in the browser inspector, just use console.log directly
your function inspect() is new, replaces lots of old stuff, and works like this
doesn't log anything, always returns a string
string is always indented, never tries to be single line
doesn't return a tick count, obviously
better than json stringify and node util inspect, actually gets the functions and stuff those miss
always indents by two spaces
goes deep, stopping at 2k of text output
uses 7 number, true boolean, "string", [array], {object}, function()
if you want to see the name of an object, you have to wrap like inspect({object})
test with exception objects
you're going to use inspect to see what third party rest apis are telling your worker

log
starts with timestamp and tilde
logs to record and console.log
turns everything into text, always, using say
keeps everything on one line, always
doesn't call inspect, ever--you have to call that manually

say
turns directly into text, succicently--inspect is the verbose and deep one







*/
















/*
2024may16
dustiest corner of the bike shed
make sure your log and see plan is good before you go back in there
-get rid of log destinations
-do program an indented deep object sayer
-dont use it when there's a browser inspector which has arrows




*/




/*
more bikeshedding here, but what if log worked like this
log(a)
turns a into text, and prefixes it with the timestamp
log(a, b)
not sure anymore
the thing you forgot when designing this refactor above was that in the browser, you don't want everything text, because the browser inspector has arrows to go deep into nested objects, which you won't code yourself, and which is incredible




*/


/*
moar notes and ideas

instead of see doing lines like
(string) s "hello"
all you need is "hello" because quotes mean string
{object}
[array]
"string"
7 with no punctuation is a number
true with no punctuation is a boolean


you made the separte vite entry point
but now nuxt localhost:3000/test is working so well you don't need it(?)
like, it's just as fast
and you can Ctrl+S library0.js several times in a row and it refreshes each time
and, the text stays in place on the page, and also scrolls down in the console
so, what more is there to do here?
i guess refactor it so you don't have log destinations anymore

*/






/*
TODO
see is too confusing; your planned replacement will be called inspect
so then the core functions are log, say, and inspect
*/
/*
export function see(...a) {//see into things, including key name, type, and value
	let s = ''
	for (let i = 0; i < a.length; i++) {
		s += (a.length > 1 ? newline : '') + _see2(a[i])//put multiple arguments on separate lines
	}
	return s
}
function _see2(o) {
	let s = ''
	if (o instanceof Error) {
		s = '(error) ' + o.stack//errors have their information here
	} else if (Array.isArray(o)) {
		s = `(array) [${o}]`
	} else if (typeof o == 'object') {
		s += '(object) {'
		let first = true
		for (let k in o) {
			if (!first) { s += ', ' } else { first = false }//separate with commas, but not first
			s += `${k} (${typeof o[k]}) ${_see3(o[k])}`
		}
		s += '}'
	} else {
		s = `(${typeof o}) ${_see3(o)}`
	}
	return s
}
function _see3(o) {
	try {
		return JSON.stringify(o, null)//single line
	} catch (e) { return '(circular reference)' }//watch out for circular references
}
*/




/*
todo, javascript is so wonky it's hard to make a see that lets you easily look inside
here are some possible improvements
get things on multiple lines and indent them 2 spaces
there's lots of:

ok (boolean) true
n (number) 7
responseText (string) ""
clone (function) undefined
o (object) {message (string) "hello"...}
a (array) [1,2,3]

shorten this so it's just:

ok: true,
n: 7,
responseText: "",
clone(),
o {
	message: "hello"
	...
},
a [1,2,3]

because json stringify skips functions, you'll probably have to write your own recursive walker and indenter
and that's fine, go three levels deep by default

moar notes for your return to this bike shed:

remove look(o), instead you have to call log(see(o))

remove the multiple loggers feature
you want icarus, but will do that later as a separate system
that system will have auto refresh
in-place traffic lights
and an in-place log that is maybe icarus()

you just remembered that log shouldn't turn everything into a string
doing so breaks the inspector's > arrow
this may also be why earlier log didn't tickstamp
if log gets a single string, do it all on one line
if log gets a single non-string, or multiple anything, call console.log multiple times for multiple lines
*/








do encoding at the same time as you do cryptography
maybe make a little object so you dont have to type Uint8array over and over again
the object is indelible
holds some binary data
and has methods to convert between all these different formats:

text, like a string of cleartext
length, how long is it in bytes when you look at it as bytes
base16
base64, checking roundtrips and whatnot

you create these from:
text strings
base16
base64
random data, cryptographically secure

following hte model, this should be tiny, it shouldn't be your node project's Data object



remind yourself of the pattern, but you think you remember it
and now you can use const!

export function Data(c) {
	const o = {}
	o.type = 'Data'//no how do you make that const?
	const type 
	

	const function fromText(s) {

	}

	const function base16()
	const function text()

	return o
}
this constructor makes a new data object

have it lazily create and then save the different forms
understand how utf8 text encoding plays a role with all this, bake that into Data as the default









server logs
dog() and log() goes to datadog
or, figure out your pattern for an api function
with a total covereage try catch
and then maybe if there's an error, inspect it into text and send it back to the browser
and even use status codes, maybe--ask chatgpt
first just see if you can get a stack trace from a worker
but then you have to make sure this isn't an attack vector, you have to know if you're built for production or not

the api full catch also dogs if it takes longer than 2s

a little clock appears in the page at 2s indicating (clock) working 2s...

dog is great because it's secure and private even in deployment--if the attacker figures out how to break an api, they can't get information mistakingly included in a log

duh the workign clock can totally be completely client-side
ask chatgpt if there's a convention in nuxt to guard against repeat requests to the same api
the don't click or you'll mess up your order, thing

ask chatgpt about the confirm form resubmission browser warning
you don't think you're coding any forms that could cause this, but understand it for the first time ever to be sure









/*
this one is for birthdates, stored in the database as text like "1980-02-14"
take the user's input free-form
allow months as feb, 2, 02, whatever
allow years 02, 2002, 76, whatever
figure out what they may mean and put up one or more buttons that snap to

you also need to take a well formatted one, and return the year, month, day as numbers

Date of birth
You must be 18+
Enter like YYYYMMDD four digit year, two digit month, two digit day
Tell us your real birthday!
Not posted on profile, kept private and secure
We check IDs for creators, date must match
Got that as January 22, 1999

If you become a creator
Must match your birthdate on your ID
Private, secure, not posted on profile
We won't post on profile
Must match your ID
Kept private from fans and collaborators
It'll
Birthday with 
that's February 14, 1980


have icarus have a little expandable text box where you can live type into a function to test it



idea for how to get dates the fastest
worst, by the way, is putting up a calendar clicker for today, asking for a dob
phone puts up number pad
instruction text says birthday, YYYYMMDD
see if you can infer other orders, including shorter orders like 040176
if they type YYMMDD, YYYYDDMM
one or two buttons pop up that say "do you mean 2002 Jan 26"
if it's ambiguous, multiple buttons pop up
a single backspace clears the whole field, maybe
*/

















